/*
 * SPARKSEE: a library for out-of-core graph-based data storage and query processing.
 *
 * See the file LICENSE.txt for redistribution information.
 *
 * Copyright (c) 2005-2010 Sparsity Technologies, Barcelona (Spain)
 */

#ifndef _SPARKSEE_DISJOINTCOMMUNITYDETECTION_H_
#define _SPARKSEE_DISJOINTCOMMUNITYDETECTION_H_

/**
 * \addtogroup algorithms
 * @{
 *
 * \file DisjointCommunityDetection.h
 * \brief It contains the definition of DisjointCommunityDetection class.
 *
 * \author Sparsity Technologies http://www.sparsity-technologies.com
 */

#include "CommunityDetection.h"
#include "DisjointCommunities.h"
#include <map>
#include <vector>


BEGIN_SPARKSEE_ALGORITHMS_NAMESPACE


/**
 * \brief DisjointCommunityDetection class.
 * 
 * Any class implementing this abstract class can be used to solve
 * a problem related to graph connectivity as finding the strongly connected
 * components, finding the weakly connected components.
 *
 * Check out the 'Algorithms' section in the SPARKSEE User Manual for more
 * details on this.
 *
 * \author Sparsity Technologies http://www.sparsity-technologies.com
 */
class SPARKSEE_EXPORT DisjointCommunityDetection : public CommunityDetection
{
public:

    /**
     * \brief Destructor.
     */
    virtual ~DisjointCommunityDetection();

    /**
     * \brief Allows connectivity through edges of the given type.
     * The edges can be used in {@link #Any} direction.
     * \param type [in] Edge type.
     */
    virtual void AddEdgeType(sparksee::gdb::type_t type);

    /**
     * \brief Allows connectivity through all edge types of the graph.
     * The edges can be used in {@link #Any} direction.
     */
    virtual void AddAllEdgeTypes();

    /**
     * Returns the results generated by the execution of the algorithm. These
     * results contain information related to the disjoint communities found
     * as the number of different components, the set of nodes contained in
     * each component or many other data.
     *
     * @return Returns an instance of the class {@link DisjointCommunities}
     * which contain information related to the disjoint communities found.
     */
    DisjointCommunities* GetCommunities();

    /** Runs the algorithm in order to find the communities.
     * <p>
     * This method can be called only once.
     */
    virtual void Run() = 0;

    /**
     * Creates a new common attribute type for all node types in the graph
     * in order to store, persistently, the results related to the disjoint
     * communities found while executing this algorithm.
     * <p>
     * Whenever the user wants to retrieve the results, even when the graph has
     * been closed and opened again, it is only necessary to create a new instance
     * of the class {@link DisjointCommunities} indicating the graph and the
     * name of the common attribute type which stores the results. This instance
     * will have all the information related to the disjoint communities found in
     * the moment of the execution of the algorithm that stored this data.
     * <p>
     * It is possible to run the algorithm without specifying this parameter in
     * order to avoid materializing the results of the execution.
     *
     * @param attributeName [in] The name of the common attribute type for all node types
     * in the graph which will store persistently the results generated by the
     * execution of the algorithm.
     */
    void SetMaterializedAttribute(const std::wstring &attributeName);


protected:

    /**
     * Creates a new instance of {@link DisjointCommunityDetection}.
     *
     * \param s [in] Session to get the graph from and calculate the communities
     */
    DisjointCommunityDetection(sparksee::gdb::Session &s);

    /**
     * \brief common attribute where the connected component information is stored.
     */
    sparksee::gdb::attr_t attrCommunity;
    /**
     * \brief name of the common attribute where the connected component information is stored.
     */
    std::wstring attrCommunityName;

    /**
     * \brief Current community identifier.
     */
    sparksee::gdb::int64_t actualCommunity;

    /**
     * \brief Materialized results.
     */
    sparksee::gdb::bool_t matResults;

    /**
     * \brief The calculated communities information.
     */
    DisjointCommunities *dcs;

    // -----------------------------------------------

    /**
     * Assigns the current community to the given node.
     */
    void SetCommunity(sparksee::gdb::oid_t idNode);

    /**
     * Check that the given attribute name is not already in use.
     */
    void AssertNotCommunityAttribute(const std::wstring &attributeName);

    /**
     * Set a new persistent global attribute to store the disjoint communities information.
     */
    void CreateGlobalPersistentAttribute(const std::wstring &attributeName);
    /**
     * Set a new temporary global attribute to store the disjoint communities information.
     */
    void CreateGlobalTransientAttribute();
    /**
     * Removes the global attribute where the disjoint communities information is stored.
     */
    void RemoveGlobalAttribute();


private:

    /**
     * \brief Non implemented to avoid use of copy constructor.
     */
    DisjointCommunityDetection(const DisjointCommunityDetection & conn);
    /**
     * \brief Non implemented to avoid use of empty constructor.
     */
    DisjointCommunityDetection();
};


END_SPARKSEE_ALGORITHMS_NAMESPACE

/** @} */
#endif // _SPARKSEE_DISJOINTCOMMUNITYDETECTION_H_
